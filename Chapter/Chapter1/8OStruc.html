<DOCTYPE html>
<html lang="en"
      xmlns:og="http://ogp.me/ns#"
      xmlns:fb="https://www.facebook.com/2008/fbml">
<head>
    <title>Angold-4 Organization</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="shortcut icon" href="./images/favicon.png"/>

    <link rel="canonical" href=".">
        <meta name="author" content="Angold Wang" />

    <meta property="og:site_name" content="Angold-4" />
<!--     <meta property="og:type" content="article"/> -->
    <meta property="og:title" content="Angold-4 Organization"/>
    <meta property="og:url" content="."/>

    <!-- Bootstrap -->
        <link rel="stylesheet" href="./theme/css/bootstrap.flatly.min.css" type="text/css"/>
    <link href="./theme/css/font-awesome.min.css" rel="stylesheet">
<!--     <link href="https://cdnjs.cloudflare.com/ajax/libs/typicons/2.0.9/typicons.min.css" rel="stylesheet"> -->

    <link href="./theme/css/pygments/monokai.css" rel="stylesheet">
    <link rel="stylesheet" href="./theme/css/style.css" type="text/css"/>

</head>
<body>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
<!-- <script src="https://code.jquery.com/jquery-2.2.4.min.js" integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin="anonymous"></script> -->
<style>
#banner{
    background-image:url("images/banner.jpg");
}
body {
    padding-top: 50px;
}
</style>

<div id="banner">
    <div class="container">
        <div class="copy">
            <h1>Webinar <br>SPRING 2022</h1>
	    <p class="intro">What happens underneath?</p>
        </div>
    </div>
</div>

<div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="./" class="navbar-brand">
<img src="./images/logo.png" width="32"/> Angold4            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav">
			    <li><a href="./about.html">About</a>
                            <li><a href="./blogs.html">Blogs</a>
                            <li><a href="./projects.html">Projects</a>
	    </ul>
            <ul class="nav navbar-nav navbar-right">
                <li> <a title="Youtube" href="https://www.youtube.com/channel/UC3ZAjh2LHhm-FrgxgBtgMzQ" target="_new"><i class="fa fa-youtube"></i> Youtube</a>
		</li>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->


<div class="container">
    <div class="row">
        <div class="col-lg-12">

<section id="content" class="body">

<h3>Operating Systerms Design and Implementation Notes</h3>
<h5>By Jiawei Wang</h5>
<h1>8. Operating System Structure</h1>
<p><strong>Now that we have seen what operating systems look like on the outside (i.e, the programmer’s interface), it is time to take a look inside.</strong><!-- raw HTML omitted -->
<strong>In the Following sections, We will introduce Oprating System briefly in 5 point of views:</strong><!-- raw HTML omitted --></p>
<!-- raw HTML omitted -->
<ul>
<li><a href="#1-monolithic-systems">1. Monolithic Systems</a></li>
<li><a href="#2-layered-systems">2. Layered Systems</a></li>
<li><a href="#3-virtual-machines">3. Virtual Machines</a></li>
<li><a href="#4-exokernels">4. Exokernels</a></li>
<li><a href="#5-client-server-model">5. Client-Server Model</a></li>
</ul>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h2>1. Monolithic Systems</h2>
<p><strong>In this point of view. The OS is written as a collection of procedures.</strong><!-- raw HTML omitted --></p>
<ul>
<li><strong>Each of procedures can call any of the other ones whenever it needs to.</strong></li>
<li><strong>Each procedure in the system has a well-defined interface in terms of parameters and results</strong></li>
<li><strong>Each one is free to call any other one, if the latter provides some useful computation that the former needs.</strong>
<!-- raw HTML omitted --></li>
</ul>
<p><strong>This is a good time to look at how system calls are performed in this point of view.</strong><!-- raw HTML omitted -->
<strong>Let's see this <code>read</code> system call:</strong><!-- raw HTML omitted --></p>
<pre><code class="language-c">count = read(fd, &amp;buffer, nbytes);
</code></pre>
<p><img src="Sources/monolithic.png" alt="monolithic"></p>
<p><strong>In preparation for calling the read library procedure, which actually makes the <code>read</code> system call.</strong><!-- raw HTML omitted -->
<strong>(Please notice that the following point 1 to 11 are correspond to the 11 steps in figure 1.16 above)</strong></p>
<ol>
<li><strong>The calling program pushes the parameters onto the stack(nbytes)</strong></li>
<li><strong>The calling program pushes the parameters onto the stack(buffer)</strong></li>
<li><strong>The calling program pushes the parameters onto the stack(fd)</strong></li>
<li><strong>Then comes the actual call to the library procedure <code>read</code>.</strong></li>
<li><strong>Execute the library procedure <code>read</code>, It possibly written in assembly language, typically puts the system call number in a place where the operating system expects it, such as a register.</strong></li>
<li><strong>This step is the continuous of step 5, Then it executes a TRAP instruction to switch from user mode to kernel mode and start execution at a fixed address within the kernel.</strong></li>
<li><strong>Within the kernel, the kernel code that starts examines the system call number and then dispatches to the correct system call handler, usually via a table of pointers to system call handlers indexed on system call number.</strong></li>
<li><strong>At that point the system call handler runs <!-- raw HTML omitted -->(This is the formal handler)<!-- raw HTML omitted --></strong></li>
<li><strong>Once the system call handler has completed its work, control may be returned to the user-space library procedure at the instruction following the TRAP instruction.</strong></li>
<li><strong>This procedure then returns to the user program(The program called <code>read</code> system call) in the usual way procedure calls return</strong></li>
<li><strong>To finish the job, the user program has to clean up the stack, as it does after any procedure call.</strong></li>
</ol>
<blockquote>
<p><strong>Assuming the stack grows downward, as it often does, the compiled code increments the stack pointer exactly enough to remove the parameters pushed before the call to read. The program is now free to do whatever it wants to do next.</strong>
<!-- raw HTML omitted --></p>
</blockquote>
<p><strong>This organization suggests a basic structure for the operating system:</strong></p>
<ol>
<li><strong>A main program that invokes the requested service procedure.<!-- raw HTML omitted --><!-- raw HTML omitted -->i.e: The user program which called the system call<!-- raw HTML omitted --></strong></li>
<li><strong>A set of service procedures that carry out the system calls.<!-- raw HTML omitted --><!-- raw HTML omitted -->i.e: The system call handler inside the kernel (8)<!-- raw HTML omitted --></strong></li>
<li><strong>A set of utility procedures that help the service procedures.<!-- raw HTML omitted --><!-- raw HTML omitted -->i.e: Specific operation. Such as fetching data from user programs or clean up the stack<!-- raw HTML omitted --></strong></li>
</ol>
<!-- raw HTML omitted -->
<p><img src="Sources/monolithicmodel.png" alt="monolithicmodel"></p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h2>2. Layered Systems</h2>
<p><strong>The system had 6 layers, as shown in Fig. 1-18.</strong><!-- raw HTML omitted --></p>
<p><img src="Sources/layered.png" alt="layered">
<!-- raw HTML omitted --></p>
<p><strong>For details each book, please check No.64 to 65 pages in the book</strong><!-- raw HTML omitted -->
<strong>Each layer conceals certain details, and by providing some interfaces upwards, the upper-level program does not need to consider specific details.</strong><!-- raw HTML omitted --></p>
<p><strong>For example:<!-- raw HTML omitted --></strong>
<strong>Layer 0 dealt with allocation of the processor, switching between processes when interrupts occurred or timers expired.<!-- raw HTML omitted -->Above layer 0, the system consisted of sequential processes, each of which could be programmed without having to worry about the fact that multiple processes were running on a single processor. In other words, layer 0 provided the basic multiprogramming of the CPU.</strong></p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h2>3. Virtual Machines</h2>
<p><strong>Before We introduce OS in this point of view, to make a better understanding.  It is important to know some history about it.<!-- raw HTML omitted --></strong></p>
<blockquote>
<p><strong>The initial releases of OS/360 were strictly batch systems. Nevertheless, many 360 users wanted to have timesharing, so various groups, both inside and outside IBM decided to write timesharing systems for it. The official IBM timesharing system, TSS/360, was delivered late, and when it finally arrived it was so big and slow that few sites converted over to it. It was eventually abandoned after its development had consumed some $50 million (Graham, 1970). But a group at IBM’s Scientific Center in Cambridge, Massachusetts, produced a radically dif- ferent system that IBM eventually accepted as a product, and which is now widely used on its mainframes.</strong></p>
</blockquote>
<!-- raw HTML omitted -->
<p><strong>This system, originally called CP/CMS and later renamed VM/370, was based on a very astute observation:<!-- raw HTML omitted -->A timesharing system provides:<!-- raw HTML omitted -->(1) multiprogramming and (2) an extended machine with a more convenient interface than the bare hardware.</strong><!-- raw HTML omitted --></p>
<p><strong>The heart of the system, known as the <!-- raw HTML omitted -->virtual machine monitor<!-- raw HTML omitted -->, runs on the bare hardware and does the multiprogramming, providing not one, but several <!-- raw HTML omitted -->virtual machines<!-- raw HTML omitted --> to the next layer up, as shown in Fig. 1-19.</strong><!-- raw HTML omitted --></p>
<p><img src="Sources/vm.png" alt="vm"></p>
<p><strong>The <a href="https://en.wikipedia.org/wiki/Virtual_machine">virtual machine</a> is a software which modify the hardware, including kernel/user mode, I/O, interrupts, and everything else the real machine has.</strong><!-- raw HTML omitted -->
<strong>In this point of view, maybe we can understand the meaning of <!-- raw HTML omitted -->OS is the virtual machine monitor<!-- raw HTML omitted -->:<!-- raw HTML omitted --></strong>
<strong>When a CMS program executes a system call, the call is trapped to the operating system in its own virtual machine, not to VM/370, just as it would if it were running on a real machine instead of a virtual one. CMS then issues the normal hardware I/O instructions for reading its virtual disk or whatever is needed to carry out the call. <!-- raw HTML omitted -->These I/O instructions are trapped by VM/370<!-- raw HTML omitted -->, which then performs them as part of its simulation of the real hardware.</strong><!-- raw HTML omitted --></p>
<p><strong>In this example above, we can find that the OS is the manager of all virtual machine at this time. By making a complete separation of the functions of multiprogramming and providing an extended machine, each of the pieces can be much simpler, more flexible, and easier to maintain.</strong>
<!-- raw HTML omitted --></p>
<p><strong>Several virtual machine implementations are marketed commercially. For example, today it is very convinent to run Linux on Windows through <a href="https://www.microsoft.com/en-hk/download/details.aspx?id=3702">Virtual PC</a> or other virture machine software. The nature of them were all provide a <!-- raw HTML omitted -->virtual machine monitor<!-- raw HTML omitted --> layer between Two systems and handle all system calls just like below.</strong><!-- raw HTML omitted --></p>
<p><img src="Sources/virtualbox.png" alt="virtualbox"><!-- raw HTML omitted --></p>
<p><img src="Sources/minix3mac.png" alt="minix3mac"><!-- raw HTML omitted --></p>
<p><strong>Run <a href="https://wiki.minix3.org/doku.php?id=www:download:start">MINIX3.3</a> in OS X by using <a href="https://www.virtualbox.org/wiki/Downloads">Virtual Box</a></strong></p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h2>4. Exokernels</h2>
<p><strong>With VM/370, each user process gets an exact copy of the actual computer. Going one step further, researchers at M.I.T. built a system that gives each user a clone of the actual computer, but with a subset of the resources<!-- raw HTML omitted --></strong></p>
<p><strong>For example: Thus one virtual machine might get disk blocks 0 to 1023, the next one might get blocks 1024 to 2047, and so on.</strong><!-- raw HTML omitted -->
<strong>At the bottom layer, running in kernel mode, is a program called the <a href="https://en.wikipedia.org/wiki/Exokernel">exokernel</a>. Its job is to allocate resources to virtual machines and then check attempts to use them to make sure no machine is trying to use somebody else’s resources. Each user-level virtual machine can run its own operating system, as on VM/370, except that each one is restricted to using only the resources it has asked for and been allocated.</strong>
<!-- raw HTML omitted --></p>
<p><img src="Sources/Exokernel.png" alt="Exokernel"><!-- raw HTML omitted -->
<strong><a href="https://commons.wikimedia.org/w/index.php?curid=25131239">Provided by Thorben Bochenek, CC BY-SA 3.0</a></strong><!-- raw HTML omitted --></p>
<p><strong>The advantage of the exokernel scheme is that it saves a layer of mapping. In the other designs, each virtual machine thinks it has its own disk, with blocks running from 0 to some maximum, so the virtual machine monitor must maintain tables to remap disk addresses (and all other resources).</strong><!-- raw HTML omitted -->
<strong>With the exokernel, this remapping is not needed. The exokernel need only keep track of which virtual machine has been assigned which resource, since all the exokernel has to do is keep the virtual machines out of each other’s hair.</strong></p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h2>5. Client-Server Model</h2>
<p><strong>VM/370 gains much in simplicity by moving a large part of the traditional operating system code (implementing the extended machine) into a higher layer, CMS. Nevertheless, VM/370 itself is still a complex program because simulating a number of virtual 370s is not that simple (especially if you want to do it reasonably efficiently and in large systems).</strong>
<!-- raw HTML omitted --></p>
<p><strong>A trend in modern operating systems is to take this idea of moving code up into higher layers even further and remove as much as possible from the operating system, leaving a minimal kernel(Usually called <a href="https://en.wikipedia.org/wiki/Microkernel">Micro Kernel</a>).</strong>
<!-- raw HTML omitted --></p>
<p><img src="Sources/microkernel.png" alt="microkernel"><!-- raw HTML omitted -->
<strong><a href="https://commons.wikimedia.org/wiki/File:OS-structure2.svg">https://commons.wikimedia.org/wiki/File:OS-structure2.svg</a></strong><!-- raw HTML omitted --></p>
<p><strong>As we can see in the picture below: The Kernel Space in Monolithic Kernel is much bigger than which in Micro Kernel.<!-- raw HTML omitted -->In Micro Kernel. The reason is to implement most of the operating system functions in user processes. To request a service, such as reading a block of a file, a user process sends the request to a server process, which then does the work and sends back the answer.</strong>
<!-- raw HTML omitted --></p>
<p><strong>In this model, shown in Fig. 1-20, <!-- raw HTML omitted -->all the kernel does is handle the communication between clients and servers.<!-- raw HTML omitted --> <!-- raw HTML omitted -->By splitting the operating system up into parts, each of which only handles one facet of the system, such as file service, process service, terminal service, or memory service, each part becomes small and manageable. <!-- raw HTML omitted -->Furthermore, because all the servers run as user-mode processes, and not in kernel mode, they do not have direct access to the hardware. As a consequence, if a bug in the file server is triggered, the file service may crash, but this will not usually bring the whole machine down.</strong></p>
<p><img src="Sources/microkernelmodel.png" alt="microkernelmodel"><!-- raw HTML omitted --></p>
<p><strong>Another advantage of the client-server model is its adaptability to use in distributed systems (see Fig. 1-21).<!-- raw HTML omitted --><!-- raw HTML omitted -->If a client communicates with a server by sending it messages, the client need not know whether the message is handled locally in its own machine, or whether it was sent across a network to a server on a remote machine. As far as the client is concerned, the same thing happens in both cases: a request was sent and a reply came back.</strong>
<!-- raw HTML omitted --></p>
<p><img src="Sources/distributed.png" alt="distributed">
<!-- raw HTML omitted --></p>
<p><strong>However, in reality, the microkernel is not on the same level as the monolithic kernel. We do not use it or accept it. In addition to the preconceived factors caused by commercial and ecological factors, there is a more important factor -- Performance.</strong></p>
	</section>
	</div>
    </div>

<div id="disqus_thread"></div>
<script>
    var disqus_config = function () {
this.page.url = "https://angold4.org/OSDI/Chapter/Chapter1/8OStruc.html"
this.page.identifier = "OSDI/Chapter/Chapter1/8OStruc.html"

    };
    (function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = 'https://angold.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
    })();
</script>

<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</div>
<footer>
   <div class="well well-lg" id="footer-well">
      <div class="container">


      <div class="row">
         <div class="col-xs-6">
            <a href="https://angold4.org" title="Angold-4 Organization" class="image-link"><img src="../../../images/logo.png" class="cmudb-logo" /></a>
         </div>
         <div class="col-xs-6">
            <p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p>
        </div>
      </div>
   </div>
   </div>
</footer>
<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="../../../theme/js/bootstrap.min.js"></script>

<!-- Enable responsive features in IE8 with Respond.js (https://github.com/scottjehl/Respond) -->
<script src="../../../theme/js/respond.min.js"></script>

<!-- Fix scrolling issues to internal HREFs that get positioned behind navbar -->
<!-- http://stackoverflow.com/questions/10732690/offsetting-an-html-anchor-to-adjust-for-fixed-header -->
<script src="../../../theme/js/href_scroll.js"></script>

<!-- You know what this is and you know what he did to me... -->
<script src="../../../theme/js/tim-kraska-betrayed-me.js"></script>
</body>
</html>

